# Day 1 - intro to unix/linux coding

My bioinformatics workflows usually begin on a unix/linux command line interface (CLI) and end in R studio. The CLI takes advantage of 
OSU's computing infrastructure to handle big data processing using memory intensive programs. The final output from these programs is in 
a smaller, more interpretable format that can be imported into R studio for data analysis and visualizations.

For example, my RNAseq workflow begins with the RNA reads generated by an Illumina NextSeq, which I begin processing on the CLI. 

[Here](https://www.youtube.com/watch?v=fCd6B5HRaZ8) is a nice short video about how Illumina sequencing works if you would like a refresher. The important takeaways for data processing are that reads of a predetermined consistent length are generated be the sequencing machine. These reads can either be [single end](https://www.illumina.com/science/technology/next-generation-sequencing/plan-experiments/paired-end-vs-single-read.html) (one sequence in one direction is generated per DNA or RNA fragment) or paired end (two sequences covering the forward and reverse direction of each read are generated). The RNA data we are working with is paired end. Using paired end data improves that read mapping step, as it's easier to correctly map a read if it has a second, complimentary read to map at the other end of the fragment.

The RNAseq workflow I use begins with those paired-end reads, then filters them to remove adapters, poly-A tails, low quality bases, and 
ribosomal RNA (rRNA). When the sequencing machine does it's sequencing, it also assigns a quality score to each base call that represents 
how confident the call is. We can set a certain quality threshold that tells a program what reads to keep, and what reads to filter out. 

After filtering, the reads are mapped to the reference genome and then sorted. The last CLI data processing task is then to use a program 
to count how many reads are mapping to each gene. The output from this is a counts matrix, where the columns are the samples in the 
experiment and the rows are the genes. This way, we can compare the relative expression (number of counts) of each gene between samples. 

This project will be more targetted than a standard RNAseq experiment, in which we would look at the whole transcriptome. We will focus 
our analysis on NLR genes (nucleotide-binding leucine-rich repeats) which are a group of genes related to plant immunity that are highly 
conserved across the plant kingdom.


coding languages - bash, c, tcsh

basic reading about shell and cluster infrastructure

navigation
cd, ls, mkdir
tree
tab complete

running programs
which program for an example
many of these programs are set as an environmental variable on our cluster, so they can be run without specifying the path to the program. but that is, in essence, what it is doing. 


#####

a sod paper
SOD dashboard
